/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  PaginatedWaitingListEntryDetailsList,
  PatchedWaitingListEntryRequest,
  WaitingListEntry,
  WaitingListEntryRequest,
  WaitingListEntryUpdateRequest,
} from "../models/index";
import {
  PaginatedWaitingListEntryDetailsListFromJSON,
  PatchedWaitingListEntryRequestToJSON,
  WaitingListEntryFromJSON,
  WaitingListEntryRequestToJSON,
  WaitingListEntryUpdateRequestToJSON,
} from "../models/index";

export interface WaitingListApiListListRequest {
  limit: number;
  offset: number;
}

export interface WaitingListApiUpdateEntryCreateRequest {
  waitingListEntryUpdateRequest: WaitingListEntryUpdateRequest;
}

export interface WaitingListWaitingListEntriesCreateRequest {
  waitingListEntryRequest: WaitingListEntryRequest;
}

export interface WaitingListWaitingListEntriesDestroyRequest {
  id: string;
}

export interface WaitingListWaitingListEntriesPartialUpdateRequest {
  id: string;
  patchedWaitingListEntryRequest?: PatchedWaitingListEntryRequest;
}

export interface WaitingListWaitingListEntriesRetrieveRequest {
  id: string;
}

export interface WaitingListWaitingListEntriesUpdateRequest {
  id: string;
  waitingListEntryRequest: WaitingListEntryRequest;
}

/**
 *
 */
export class WaitingListApi extends runtime.BaseAPI {
  /**
   */
  async waitingListApiCategoriesRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/categories`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  async waitingListApiCategoriesRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string>> {
    const response =
      await this.waitingListApiCategoriesRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiListListRaw(
    requestParameters: WaitingListApiListListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PaginatedWaitingListEntryDetailsList>> {
    if (requestParameters["limit"] == null) {
      throw new runtime.RequiredError(
        "limit",
        'Required parameter "limit" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["offset"] == null) {
      throw new runtime.RequiredError(
        "offset",
        'Required parameter "offset" was null or undefined when calling waitingListApiListList().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/list`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PaginatedWaitingListEntryDetailsListFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiListList(
    requestParameters: WaitingListApiListListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PaginatedWaitingListEntryDetailsList> {
    const response = await this.waitingListApiListListRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiShowCoopContentRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<boolean>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/show_coop_content`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiShowCoopContentRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<boolean> {
    const response =
      await this.waitingListApiShowCoopContentRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiUpdateEntryCreateRaw(
    requestParameters: WaitingListApiUpdateEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["waitingListEntryUpdateRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryUpdateRequest",
        'Required parameter "waitingListEntryUpdateRequest" was null or undefined when calling waitingListApiUpdateEntryCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/update_entry`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryUpdateRequestToJSON(
          requestParameters["waitingListEntryUpdateRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiUpdateEntryCreate(
    requestParameters: WaitingListApiUpdateEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiUpdateEntryCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesCreateRaw(
    requestParameters: WaitingListWaitingListEntriesCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["waitingListEntryRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryRequest",
        'Required parameter "waitingListEntryRequest" was null or undefined when calling waitingListWaitingListEntriesCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryRequestToJSON(
          requestParameters["waitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesCreate(
    requestParameters: WaitingListWaitingListEntriesCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesDestroyRaw(
    requestParameters: WaitingListWaitingListEntriesDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesDestroy().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async waitingListWaitingListEntriesDestroy(
    requestParameters: WaitingListWaitingListEntriesDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.waitingListWaitingListEntriesDestroyRaw(
      requestParameters,
      initOverrides,
    );
  }

  /**
   */
  async waitingListWaitingListEntriesListRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<WaitingListEntry>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(WaitingListEntryFromJSON),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesList(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<WaitingListEntry>> {
    const response =
      await this.waitingListWaitingListEntriesListRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesPartialUpdateRaw(
    requestParameters: WaitingListWaitingListEntriesPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesPartialUpdate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: PatchedWaitingListEntryRequestToJSON(
          requestParameters["patchedWaitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesPartialUpdate(
    requestParameters: WaitingListWaitingListEntriesPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesPartialUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesRetrieveRaw(
    requestParameters: WaitingListWaitingListEntriesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesRetrieve().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesRetrieve(
    requestParameters: WaitingListWaitingListEntriesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesRetrieveRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesUpdateRaw(
    requestParameters: WaitingListWaitingListEntriesUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesUpdate().',
      );
    }

    if (requestParameters["waitingListEntryRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryRequest",
        'Required parameter "waitingListEntryRequest" was null or undefined when calling waitingListWaitingListEntriesUpdate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryRequestToJSON(
          requestParameters["waitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesUpdate(
    requestParameters: WaitingListWaitingListEntriesUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
