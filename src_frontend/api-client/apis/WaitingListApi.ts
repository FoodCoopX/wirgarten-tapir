/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  Counts,
  DisableLinkSerializerRequest,
  OrderConfirmationResponse,
  PaginatedWaitingListEntryDetailsList,
  PatchedWaitingListEntryRequest,
  PublicConfirmWaitingListEntryRequestRequest,
  PublicWaitingListEntryExistingMemberCreateRequest,
  PublicWaitingListEntryNewMemberCreateRequest,
  SendLinkSerializerRequest,
  WaitingListEntry,
  WaitingListEntryDetails,
  WaitingListEntryRequest,
  WaitingListEntryUpdateRequest,
} from "../models/index";
import {
  CountsFromJSON,
  DisableLinkSerializerRequestToJSON,
  OrderConfirmationResponseFromJSON,
  PaginatedWaitingListEntryDetailsListFromJSON,
  PatchedWaitingListEntryRequestToJSON,
  PublicConfirmWaitingListEntryRequestRequestToJSON,
  PublicWaitingListEntryExistingMemberCreateRequestToJSON,
  PublicWaitingListEntryNewMemberCreateRequestToJSON,
  SendLinkSerializerRequestToJSON,
  WaitingListEntryDetailsFromJSON,
  WaitingListEntryFromJSON,
  WaitingListEntryRequestToJSON,
  WaitingListEntryUpdateRequestToJSON,
} from "../models/index";

export interface WaitingListApiDisableWaitingListLinkCreateRequest {
  disableLinkSerializerRequest: DisableLinkSerializerRequest;
}

export interface WaitingListApiListListRequest {
  category: string;
  currentPickupLocationId: string;
  entryType: WaitingListApiListListEntryTypeEnum;
  limit: number;
  memberType: WaitingListApiListListMemberTypeEnum;
  offset: number;
  orderBy: WaitingListApiListListOrderByEnum;
  pickupLocationWish: string;
  productWish: string;
}

export interface WaitingListApiPublicConfirmWaitingListEntryCreateRequest {
  publicConfirmWaitingListEntryRequestRequest: PublicConfirmWaitingListEntryRequestRequest;
}

export interface WaitingListApiPublicGetWaitingListEntryDetailsRetrieveRequest {
  entryId: string;
  linkKey: string;
}

export interface WaitingListApiPublicWaitingListCreateEntryNewMemberCreateRequest {
  publicWaitingListEntryNewMemberCreateRequest: PublicWaitingListEntryNewMemberCreateRequest;
}

export interface WaitingListApiSendWaitingListLinkCreateRequest {
  sendLinkSerializerRequest: SendLinkSerializerRequest;
}

export interface WaitingListApiUpdateEntryCreateRequest {
  waitingListEntryUpdateRequest: WaitingListEntryUpdateRequest;
}

export interface WaitingListApiWaitingListCreateEntryExistingMemberCreateRequest {
  publicWaitingListEntryExistingMemberCreateRequest: PublicWaitingListEntryExistingMemberCreateRequest;
}

export interface WaitingListWaitingListEntriesCreateRequest {
  waitingListEntryRequest: WaitingListEntryRequest;
}

export interface WaitingListWaitingListEntriesDestroyRequest {
  id: string;
}

export interface WaitingListWaitingListEntriesPartialUpdateRequest {
  id: string;
  patchedWaitingListEntryRequest?: PatchedWaitingListEntryRequest;
}

export interface WaitingListWaitingListEntriesRetrieveRequest {
  id: string;
}

export interface WaitingListWaitingListEntriesUpdateRequest {
  id: string;
  waitingListEntryRequest: WaitingListEntryRequest;
}

/**
 *
 */
export class WaitingListApi extends runtime.BaseAPI {
  /**
   */
  async waitingListApiCategoriesRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/categories`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  async waitingListApiCategoriesRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string>> {
    const response =
      await this.waitingListApiCategoriesRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiCountsRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Counts>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/counts`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CountsFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiCountsRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Counts> {
    const response = await this.waitingListApiCountsRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiDisableWaitingListLinkCreateRaw(
    requestParameters: WaitingListApiDisableWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["disableLinkSerializerRequest"] == null) {
      throw new runtime.RequiredError(
        "disableLinkSerializerRequest",
        'Required parameter "disableLinkSerializerRequest" was null or undefined when calling waitingListApiDisableWaitingListLinkCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/disable_waiting_list_link`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DisableLinkSerializerRequestToJSON(
          requestParameters["disableLinkSerializerRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiDisableWaitingListLinkCreate(
    requestParameters: WaitingListApiDisableWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiDisableWaitingListLinkCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiListListRaw(
    requestParameters: WaitingListApiListListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PaginatedWaitingListEntryDetailsList>> {
    if (requestParameters["category"] == null) {
      throw new runtime.RequiredError(
        "category",
        'Required parameter "category" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["currentPickupLocationId"] == null) {
      throw new runtime.RequiredError(
        "currentPickupLocationId",
        'Required parameter "currentPickupLocationId" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["entryType"] == null) {
      throw new runtime.RequiredError(
        "entryType",
        'Required parameter "entryType" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["limit"] == null) {
      throw new runtime.RequiredError(
        "limit",
        'Required parameter "limit" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["memberType"] == null) {
      throw new runtime.RequiredError(
        "memberType",
        'Required parameter "memberType" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["offset"] == null) {
      throw new runtime.RequiredError(
        "offset",
        'Required parameter "offset" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["orderBy"] == null) {
      throw new runtime.RequiredError(
        "orderBy",
        'Required parameter "orderBy" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["pickupLocationWish"] == null) {
      throw new runtime.RequiredError(
        "pickupLocationWish",
        'Required parameter "pickupLocationWish" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["productWish"] == null) {
      throw new runtime.RequiredError(
        "productWish",
        'Required parameter "productWish" was null or undefined when calling waitingListApiListList().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["category"] != null) {
      queryParameters["category"] = requestParameters["category"];
    }

    if (requestParameters["currentPickupLocationId"] != null) {
      queryParameters["current_pickup_location_id"] =
        requestParameters["currentPickupLocationId"];
    }

    if (requestParameters["entryType"] != null) {
      queryParameters["entry_type"] = requestParameters["entryType"];
    }

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["memberType"] != null) {
      queryParameters["member_type"] = requestParameters["memberType"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    if (requestParameters["orderBy"] != null) {
      queryParameters["order_by"] = requestParameters["orderBy"];
    }

    if (requestParameters["pickupLocationWish"] != null) {
      queryParameters["pickup_location_wish"] =
        requestParameters["pickupLocationWish"];
    }

    if (requestParameters["productWish"] != null) {
      queryParameters["product_wish"] = requestParameters["productWish"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/list`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PaginatedWaitingListEntryDetailsListFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiListList(
    requestParameters: WaitingListApiListListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PaginatedWaitingListEntryDetailsList> {
    const response = await this.waitingListApiListListRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiPublicConfirmWaitingListEntryCreateRaw(
    requestParameters: WaitingListApiPublicConfirmWaitingListEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OrderConfirmationResponse>> {
    if (
      requestParameters["publicConfirmWaitingListEntryRequestRequest"] == null
    ) {
      throw new runtime.RequiredError(
        "publicConfirmWaitingListEntryRequestRequest",
        'Required parameter "publicConfirmWaitingListEntryRequestRequest" was null or undefined when calling waitingListApiPublicConfirmWaitingListEntryCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/public_confirm_waiting_list_entry`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublicConfirmWaitingListEntryRequestRequestToJSON(
          requestParameters["publicConfirmWaitingListEntryRequestRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderConfirmationResponseFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiPublicConfirmWaitingListEntryCreate(
    requestParameters: WaitingListApiPublicConfirmWaitingListEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OrderConfirmationResponse> {
    const response =
      await this.waitingListApiPublicConfirmWaitingListEntryCreateRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListApiPublicGetWaitingListEntryDetailsRetrieveRaw(
    requestParameters: WaitingListApiPublicGetWaitingListEntryDetailsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntryDetails>> {
    if (requestParameters["entryId"] == null) {
      throw new runtime.RequiredError(
        "entryId",
        'Required parameter "entryId" was null or undefined when calling waitingListApiPublicGetWaitingListEntryDetailsRetrieve().',
      );
    }

    if (requestParameters["linkKey"] == null) {
      throw new runtime.RequiredError(
        "linkKey",
        'Required parameter "linkKey" was null or undefined when calling waitingListApiPublicGetWaitingListEntryDetailsRetrieve().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["entryId"] != null) {
      queryParameters["entry_id"] = requestParameters["entryId"];
    }

    if (requestParameters["linkKey"] != null) {
      queryParameters["link_key"] = requestParameters["linkKey"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/public_get_waiting_list_entry_details`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryDetailsFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiPublicGetWaitingListEntryDetailsRetrieve(
    requestParameters: WaitingListApiPublicGetWaitingListEntryDetailsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntryDetails> {
    const response =
      await this.waitingListApiPublicGetWaitingListEntryDetailsRetrieveRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListApiPublicWaitingListCreateEntryNewMemberCreateRaw(
    requestParameters: WaitingListApiPublicWaitingListCreateEntryNewMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OrderConfirmationResponse>> {
    if (
      requestParameters["publicWaitingListEntryNewMemberCreateRequest"] == null
    ) {
      throw new runtime.RequiredError(
        "publicWaitingListEntryNewMemberCreateRequest",
        'Required parameter "publicWaitingListEntryNewMemberCreateRequest" was null or undefined when calling waitingListApiPublicWaitingListCreateEntryNewMemberCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/public_waiting_list_create_entry_new_member`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublicWaitingListEntryNewMemberCreateRequestToJSON(
          requestParameters["publicWaitingListEntryNewMemberCreateRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderConfirmationResponseFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiPublicWaitingListCreateEntryNewMemberCreate(
    requestParameters: WaitingListApiPublicWaitingListCreateEntryNewMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OrderConfirmationResponse> {
    const response =
      await this.waitingListApiPublicWaitingListCreateEntryNewMemberCreateRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListApiSendWaitingListLinkCreateRaw(
    requestParameters: WaitingListApiSendWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["sendLinkSerializerRequest"] == null) {
      throw new runtime.RequiredError(
        "sendLinkSerializerRequest",
        'Required parameter "sendLinkSerializerRequest" was null or undefined when calling waitingListApiSendWaitingListLinkCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/send_waiting_list_link`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SendLinkSerializerRequestToJSON(
          requestParameters["sendLinkSerializerRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiSendWaitingListLinkCreate(
    requestParameters: WaitingListApiSendWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiSendWaitingListLinkCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiShowCoopContentRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<boolean>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/show_coop_content`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiShowCoopContentRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<boolean> {
    const response =
      await this.waitingListApiShowCoopContentRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiUpdateEntryCreateRaw(
    requestParameters: WaitingListApiUpdateEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["waitingListEntryUpdateRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryUpdateRequest",
        'Required parameter "waitingListEntryUpdateRequest" was null or undefined when calling waitingListApiUpdateEntryCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/update_entry`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryUpdateRequestToJSON(
          requestParameters["waitingListEntryUpdateRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiUpdateEntryCreate(
    requestParameters: WaitingListApiUpdateEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiUpdateEntryCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiWaitingListCreateEntryExistingMemberCreateRaw(
    requestParameters: WaitingListApiWaitingListCreateEntryExistingMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OrderConfirmationResponse>> {
    if (
      requestParameters["publicWaitingListEntryExistingMemberCreateRequest"] ==
      null
    ) {
      throw new runtime.RequiredError(
        "publicWaitingListEntryExistingMemberCreateRequest",
        'Required parameter "publicWaitingListEntryExistingMemberCreateRequest" was null or undefined when calling waitingListApiWaitingListCreateEntryExistingMemberCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/waiting_list_create_entry_existing_member`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublicWaitingListEntryExistingMemberCreateRequestToJSON(
          requestParameters[
            "publicWaitingListEntryExistingMemberCreateRequest"
          ],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderConfirmationResponseFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiWaitingListCreateEntryExistingMemberCreate(
    requestParameters: WaitingListApiWaitingListCreateEntryExistingMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OrderConfirmationResponse> {
    const response =
      await this.waitingListApiWaitingListCreateEntryExistingMemberCreateRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesCreateRaw(
    requestParameters: WaitingListWaitingListEntriesCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["waitingListEntryRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryRequest",
        'Required parameter "waitingListEntryRequest" was null or undefined when calling waitingListWaitingListEntriesCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryRequestToJSON(
          requestParameters["waitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesCreate(
    requestParameters: WaitingListWaitingListEntriesCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesDestroyRaw(
    requestParameters: WaitingListWaitingListEntriesDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesDestroy().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async waitingListWaitingListEntriesDestroy(
    requestParameters: WaitingListWaitingListEntriesDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.waitingListWaitingListEntriesDestroyRaw(
      requestParameters,
      initOverrides,
    );
  }

  /**
   */
  async waitingListWaitingListEntriesListRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<WaitingListEntry>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(WaitingListEntryFromJSON),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesList(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<WaitingListEntry>> {
    const response =
      await this.waitingListWaitingListEntriesListRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesPartialUpdateRaw(
    requestParameters: WaitingListWaitingListEntriesPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesPartialUpdate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: PatchedWaitingListEntryRequestToJSON(
          requestParameters["patchedWaitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesPartialUpdate(
    requestParameters: WaitingListWaitingListEntriesPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesPartialUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesRetrieveRaw(
    requestParameters: WaitingListWaitingListEntriesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesRetrieve().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesRetrieve(
    requestParameters: WaitingListWaitingListEntriesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesRetrieveRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesUpdateRaw(
    requestParameters: WaitingListWaitingListEntriesUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesUpdate().',
      );
    }

    if (requestParameters["waitingListEntryRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryRequest",
        'Required parameter "waitingListEntryRequest" was null or undefined when calling waitingListWaitingListEntriesUpdate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (this.configuration && this.configuration.apiKey) {
      headerParameters["Authorization"] =
        await this.configuration.apiKey("Authorization"); // tokenAuth authentication
    }

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryRequestToJSON(
          requestParameters["waitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesUpdate(
    requestParameters: WaitingListWaitingListEntriesUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}

/**
 * @export
 */
export const WaitingListApiListListEntryTypeEnum = {
  Any: "any",
  MustHavePickupLocationWish: "must_have_pickup_location_wish",
  MustHaveProductWish: "must_have_product_wish",
} as const;
export type WaitingListApiListListEntryTypeEnum =
  (typeof WaitingListApiListListEntryTypeEnum)[keyof typeof WaitingListApiListListEntryTypeEnum];
/**
 * @export
 */
export const WaitingListApiListListMemberTypeEnum = {
  All: "all",
  ExistingMembers: "existing_members",
  NewMembers: "new_members",
} as const;
export type WaitingListApiListListMemberTypeEnum =
  (typeof WaitingListApiListListMemberTypeEnum)[keyof typeof WaitingListApiListListMemberTypeEnum];
/**
 * @export
 */
export const WaitingListApiListListOrderByEnum = {
  CreatedAt: "-created_at",
  MemberSince: "-member_since",
  CreatedAt2: "created_at",
  MemberSince2: "member_since",
} as const;
export type WaitingListApiListListOrderByEnum =
  (typeof WaitingListApiListListOrderByEnum)[keyof typeof WaitingListApiListListOrderByEnum];
