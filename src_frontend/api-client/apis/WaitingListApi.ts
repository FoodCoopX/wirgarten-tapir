/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from "../runtime";
import type {
  DisableLinkSerializerRequest,
  OrderConfirmationResponse,
  PaginatedWaitingListEntryDetailsList,
  PatchedWaitingListEntryRequest,
  PublicWaitingListEntryExistingMemberCreateRequest,
  PublicWaitingListEntryNewMemberCreateRequest,
  SendLinkSerializerRequest,
  WaitingListEntry,
  WaitingListEntryDetails,
  WaitingListEntryRequest,
  WaitingListEntryUpdateRequest,
} from "../models/index";
import {
  DisableLinkSerializerRequestToJSON,
  OrderConfirmationResponseFromJSON,
  PaginatedWaitingListEntryDetailsListFromJSON,
  PatchedWaitingListEntryRequestToJSON,
  PublicWaitingListEntryExistingMemberCreateRequestToJSON,
  PublicWaitingListEntryNewMemberCreateRequestToJSON,
  SendLinkSerializerRequestToJSON,
  WaitingListEntryDetailsFromJSON,
  WaitingListEntryFromJSON,
  WaitingListEntryRequestToJSON,
  WaitingListEntryUpdateRequestToJSON,
} from "../models/index";

export interface WaitingListApiDisableWaitingListLinkCreateRequest {
  disableLinkSerializerRequest: DisableLinkSerializerRequest;
}

export interface WaitingListApiListListRequest {
  limit: number;
  offset: number;
}

export interface WaitingListApiPublicGetWaitingListEntryDetailsRetrieveRequest {
  entryId: string;
  linkKey: string;
}

export interface WaitingListApiPublicWaitingListCreateEntryNewMemberCreateRequest {
  publicWaitingListEntryNewMemberCreateRequest: PublicWaitingListEntryNewMemberCreateRequest;
}

export interface WaitingListApiSendWaitingListLinkCreateRequest {
  sendLinkSerializerRequest: SendLinkSerializerRequest;
}

export interface WaitingListApiUpdateEntryCreateRequest {
  waitingListEntryUpdateRequest: WaitingListEntryUpdateRequest;
}

export interface WaitingListApiWaitingListCreateEntryExistingMemberCreateRequest {
  publicWaitingListEntryExistingMemberCreateRequest: PublicWaitingListEntryExistingMemberCreateRequest;
}

export interface WaitingListWaitingListEntriesCreateRequest {
  waitingListEntryRequest: WaitingListEntryRequest;
}

export interface WaitingListWaitingListEntriesDestroyRequest {
  id: string;
}

export interface WaitingListWaitingListEntriesPartialUpdateRequest {
  id: string;
  patchedWaitingListEntryRequest?: PatchedWaitingListEntryRequest;
}

export interface WaitingListWaitingListEntriesRetrieveRequest {
  id: string;
}

export interface WaitingListWaitingListEntriesUpdateRequest {
  id: string;
  waitingListEntryRequest: WaitingListEntryRequest;
}

/**
 *
 */
export class WaitingListApi extends runtime.BaseAPI {
  /**
   */
  async waitingListApiCategoriesRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<string>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/categories`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   */
  async waitingListApiCategoriesRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<string>> {
    const response =
      await this.waitingListApiCategoriesRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiDisableWaitingListLinkCreateRaw(
    requestParameters: WaitingListApiDisableWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["disableLinkSerializerRequest"] == null) {
      throw new runtime.RequiredError(
        "disableLinkSerializerRequest",
        'Required parameter "disableLinkSerializerRequest" was null or undefined when calling waitingListApiDisableWaitingListLinkCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/disable_waiting_list_link`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: DisableLinkSerializerRequestToJSON(
          requestParameters["disableLinkSerializerRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiDisableWaitingListLinkCreate(
    requestParameters: WaitingListApiDisableWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiDisableWaitingListLinkCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiListListRaw(
    requestParameters: WaitingListApiListListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<PaginatedWaitingListEntryDetailsList>> {
    if (requestParameters["limit"] == null) {
      throw new runtime.RequiredError(
        "limit",
        'Required parameter "limit" was null or undefined when calling waitingListApiListList().',
      );
    }

    if (requestParameters["offset"] == null) {
      throw new runtime.RequiredError(
        "offset",
        'Required parameter "offset" was null or undefined when calling waitingListApiListList().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["limit"] != null) {
      queryParameters["limit"] = requestParameters["limit"];
    }

    if (requestParameters["offset"] != null) {
      queryParameters["offset"] = requestParameters["offset"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/list`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PaginatedWaitingListEntryDetailsListFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiListList(
    requestParameters: WaitingListApiListListRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<PaginatedWaitingListEntryDetailsList> {
    const response = await this.waitingListApiListListRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiPublicGetWaitingListEntryDetailsRetrieveRaw(
    requestParameters: WaitingListApiPublicGetWaitingListEntryDetailsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntryDetails>> {
    if (requestParameters["entryId"] == null) {
      throw new runtime.RequiredError(
        "entryId",
        'Required parameter "entryId" was null or undefined when calling waitingListApiPublicGetWaitingListEntryDetailsRetrieve().',
      );
    }

    if (requestParameters["linkKey"] == null) {
      throw new runtime.RequiredError(
        "linkKey",
        'Required parameter "linkKey" was null or undefined when calling waitingListApiPublicGetWaitingListEntryDetailsRetrieve().',
      );
    }

    const queryParameters: any = {};

    if (requestParameters["entryId"] != null) {
      queryParameters["entry_id"] = requestParameters["entryId"];
    }

    if (requestParameters["linkKey"] != null) {
      queryParameters["link_key"] = requestParameters["linkKey"];
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/public_get_waiting_list_entry_details`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryDetailsFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiPublicGetWaitingListEntryDetailsRetrieve(
    requestParameters: WaitingListApiPublicGetWaitingListEntryDetailsRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntryDetails> {
    const response =
      await this.waitingListApiPublicGetWaitingListEntryDetailsRetrieveRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListApiPublicWaitingListCreateEntryNewMemberCreateRaw(
    requestParameters: WaitingListApiPublicWaitingListCreateEntryNewMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OrderConfirmationResponse>> {
    if (
      requestParameters["publicWaitingListEntryNewMemberCreateRequest"] == null
    ) {
      throw new runtime.RequiredError(
        "publicWaitingListEntryNewMemberCreateRequest",
        'Required parameter "publicWaitingListEntryNewMemberCreateRequest" was null or undefined when calling waitingListApiPublicWaitingListCreateEntryNewMemberCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/public_waiting_list_create_entry_new_member`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublicWaitingListEntryNewMemberCreateRequestToJSON(
          requestParameters["publicWaitingListEntryNewMemberCreateRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderConfirmationResponseFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiPublicWaitingListCreateEntryNewMemberCreate(
    requestParameters: WaitingListApiPublicWaitingListCreateEntryNewMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OrderConfirmationResponse> {
    const response =
      await this.waitingListApiPublicWaitingListCreateEntryNewMemberCreateRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListApiSendWaitingListLinkCreateRaw(
    requestParameters: WaitingListApiSendWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["sendLinkSerializerRequest"] == null) {
      throw new runtime.RequiredError(
        "sendLinkSerializerRequest",
        'Required parameter "sendLinkSerializerRequest" was null or undefined when calling waitingListApiSendWaitingListLinkCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/send_waiting_list_link`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SendLinkSerializerRequestToJSON(
          requestParameters["sendLinkSerializerRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiSendWaitingListLinkCreate(
    requestParameters: WaitingListApiSendWaitingListLinkCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiSendWaitingListLinkCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiShowCoopContentRetrieveRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<boolean>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/show_coop_content`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<boolean>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiShowCoopContentRetrieve(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<boolean> {
    const response =
      await this.waitingListApiShowCoopContentRetrieveRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListApiUpdateEntryCreateRaw(
    requestParameters: WaitingListApiUpdateEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<string>> {
    if (requestParameters["waitingListEntryUpdateRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryUpdateRequest",
        'Required parameter "waitingListEntryUpdateRequest" was null or undefined when calling waitingListApiUpdateEntryCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/update_entry`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryUpdateRequestToJSON(
          requestParameters["waitingListEntryUpdateRequest"],
        ),
      },
      initOverrides,
    );

    if (this.isJsonMime(response.headers.get("content-type"))) {
      return new runtime.JSONApiResponse<string>(response);
    } else {
      return new runtime.TextApiResponse(response) as any;
    }
  }

  /**
   */
  async waitingListApiUpdateEntryCreate(
    requestParameters: WaitingListApiUpdateEntryCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<string> {
    const response = await this.waitingListApiUpdateEntryCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListApiWaitingListCreateEntryExistingMemberCreateRaw(
    requestParameters: WaitingListApiWaitingListCreateEntryExistingMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<OrderConfirmationResponse>> {
    if (
      requestParameters["publicWaitingListEntryExistingMemberCreateRequest"] ==
      null
    ) {
      throw new runtime.RequiredError(
        "publicWaitingListEntryExistingMemberCreateRequest",
        'Required parameter "publicWaitingListEntryExistingMemberCreateRequest" was null or undefined when calling waitingListApiWaitingListCreateEntryExistingMemberCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/api/waiting_list_create_entry_existing_member`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: PublicWaitingListEntryExistingMemberCreateRequestToJSON(
          requestParameters[
            "publicWaitingListEntryExistingMemberCreateRequest"
          ],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      OrderConfirmationResponseFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListApiWaitingListCreateEntryExistingMemberCreate(
    requestParameters: WaitingListApiWaitingListCreateEntryExistingMemberCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<OrderConfirmationResponse> {
    const response =
      await this.waitingListApiWaitingListCreateEntryExistingMemberCreateRaw(
        requestParameters,
        initOverrides,
      );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesCreateRaw(
    requestParameters: WaitingListWaitingListEntriesCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["waitingListEntryRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryRequest",
        'Required parameter "waitingListEntryRequest" was null or undefined when calling waitingListWaitingListEntriesCreate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryRequestToJSON(
          requestParameters["waitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesCreate(
    requestParameters: WaitingListWaitingListEntriesCreateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesCreateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesDestroyRaw(
    requestParameters: WaitingListWaitingListEntriesDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesDestroy().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "DELETE",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   */
  async waitingListWaitingListEntriesDestroy(
    requestParameters: WaitingListWaitingListEntriesDestroyRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<void> {
    await this.waitingListWaitingListEntriesDestroyRaw(
      requestParameters,
      initOverrides,
    );
  }

  /**
   */
  async waitingListWaitingListEntriesListRaw(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<Array<WaitingListEntry>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(WaitingListEntryFromJSON),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesList(
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<Array<WaitingListEntry>> {
    const response =
      await this.waitingListWaitingListEntriesListRaw(initOverrides);
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesPartialUpdateRaw(
    requestParameters: WaitingListWaitingListEntriesPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesPartialUpdate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "PATCH",
        headers: headerParameters,
        query: queryParameters,
        body: PatchedWaitingListEntryRequestToJSON(
          requestParameters["patchedWaitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesPartialUpdate(
    requestParameters: WaitingListWaitingListEntriesPartialUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesPartialUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesRetrieveRaw(
    requestParameters: WaitingListWaitingListEntriesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesRetrieve().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "GET",
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesRetrieve(
    requestParameters: WaitingListWaitingListEntriesRetrieveRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesRetrieveRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }

  /**
   */
  async waitingListWaitingListEntriesUpdateRaw(
    requestParameters: WaitingListWaitingListEntriesUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<runtime.ApiResponse<WaitingListEntry>> {
    if (requestParameters["id"] == null) {
      throw new runtime.RequiredError(
        "id",
        'Required parameter "id" was null or undefined when calling waitingListWaitingListEntriesUpdate().',
      );
    }

    if (requestParameters["waitingListEntryRequest"] == null) {
      throw new runtime.RequiredError(
        "waitingListEntryRequest",
        'Required parameter "waitingListEntryRequest" was null or undefined when calling waitingListWaitingListEntriesUpdate().',
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters["Content-Type"] = "application/json";

    if (
      this.configuration &&
      (this.configuration.username !== undefined ||
        this.configuration.password !== undefined)
    ) {
      headerParameters["Authorization"] =
        "Basic " +
        btoa(this.configuration.username + ":" + this.configuration.password);
    }
    const response = await this.request(
      {
        path: `/waiting_list/waiting_list_entries/{id}/`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(requestParameters["id"])),
        ),
        method: "PUT",
        headers: headerParameters,
        query: queryParameters,
        body: WaitingListEntryRequestToJSON(
          requestParameters["waitingListEntryRequest"],
        ),
      },
      initOverrides,
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      WaitingListEntryFromJSON(jsonValue),
    );
  }

  /**
   */
  async waitingListWaitingListEntriesUpdate(
    requestParameters: WaitingListWaitingListEntriesUpdateRequest,
    initOverrides?: RequestInit | runtime.InitOverrideFunction,
  ): Promise<WaitingListEntry> {
    const response = await this.waitingListWaitingListEntriesUpdateRaw(
      requestParameters,
      initOverrides,
    );
    return await response.value();
  }
}
